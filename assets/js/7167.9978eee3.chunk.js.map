{"version":3,"file":"assets/js/7167.9978eee3.chunk.js","mappings":"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","sources":["webpack://job-tracker-dashboard/./src/features/applications/firestore/lib/text.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/fingerprint.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/lib/constants.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/lib/time.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/index.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/matching.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/followUp.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/reapply.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/derived/priority.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/lib/sanitize.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/refs.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/lib/patch.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/user.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/api.ts","webpack://job-tracker-dashboard/./src/features/applications/firestore/history.ts"],"sourcesContent":["/**\n * Stable lightweight hash for fingerprinting.\n * (Not cryptographic; good enough for roleFingerprint dedupe.)\n */\nexport function djb2Hash(input: string): string {\n  let hash = 5381;\n  for (let i = 0; i < input.length; i += 1) {\n    hash = (hash * 33) ^ input.charCodeAt(i);\n  }\n  // convert to unsigned 32-bit and base36\n  return (hash >>> 0).toString(36);\n}\n\nexport function normalizeText(s: string): string {\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9а-яё#+.\\s-]/gi, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n","import { djb2Hash, normalizeText } from \"../lib/text\";\nimport { ApplicationDoc } from \"../types\";\n\nexport function computeRoleFingerprint(app: ApplicationDoc): string {\n  const base = `${app.job.companyName}::${app.job.roleTitle}::${app.job.locationText ?? \"\"}`;\n  return `rf_${djb2Hash(normalizeText(base))}`;\n}\n\nexport function withRoleFingerprint(\n  app: ApplicationDoc,\n  roleFingerprint: string,\n): ApplicationDoc {\n  return {\n    ...app,\n    vacancy: { ...(app.vacancy ?? {}), roleFingerprint },\n  };\n}\n","export const DAY_MS = 24 * 60 * 60 * 1000;\nexport const FOLLOW_UP_DAYS = 7;\nexport const REAPPLY_COOLDOWN_DAYS = 30;\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { DAY_MS } from \"./constants\";\n\nexport function nowTs(): Timestamp {\n  return Timestamp.now();\n}\n\nexport function addDays(ts: Timestamp, days: number): Timestamp {\n  return Timestamp.fromMillis(ts.toMillis() + days * DAY_MS);\n}\n\nexport function daysBetween(a: Timestamp, b: Timestamp): number {\n  return Math.floor(Math.abs(a.toMillis() - b.toMillis()) / DAY_MS);\n}\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { ApplicationDoc, DotPatch, MatchingBlock, PriorityBlock, UserDoc } from \"../types\";\n\nimport { computeRoleFingerprint, withRoleFingerprint } from \"./fingerprint\";\nimport { computeFollowUp } from \"./followUp\";\nimport { computeMatching } from \"./matching\";\nimport { computePriority } from \"./priority\";\nimport { computeReapply } from \"./reapply\";\n\nexport type DerivedComputation = {\n  roleFingerprint: string;\n  matching?: MatchingBlock;\n  followUp: {\n    needsFollowUp: boolean;\n    followUpDueAt?: Timestamp;\n    followUpLevel: number;\n  };\n  reapply: {\n    needsReapplySuggestion: boolean;\n    reapplyEligibleAt?: Timestamp;\n    reapplyReason?: string;\n  };\n  priority: PriorityBlock;\n};\n\nexport function computeDerived(\n  user: UserDoc | null,\n  app: ApplicationDoc,\n  t: Timestamp,\n): DerivedComputation {\n  const roleFingerprint = app.vacancy?.roleFingerprint ?? computeRoleFingerprint(app);\n\n  const base = withRoleFingerprint(app, roleFingerprint);\n  const matching = computeMatching(user, base, t);\n\n  const followUp = computeFollowUp({ ...base, matching }, t);\n  const reapply = computeReapply(\n    {\n      ...base,\n      matching,\n      process: { ...base.process, ...followUp },\n    },\n    t,\n  );\n\n  const withDerived: ApplicationDoc = {\n    ...base,\n    matching,\n    process: { ...base.process, ...followUp, ...reapply },\n  };\n  const priority = computePriority(withDerived, t);\n\n  return { roleFingerprint, matching, followUp, reapply, priority };\n}\n\nexport function buildDerivedPatch(d: DerivedComputation): DotPatch {\n  return {\n    \"vacancy.roleFingerprint\": d.roleFingerprint,\n    matching: d.matching,\n    priority: d.priority,\n    \"process.needsFollowUp\": d.followUp.needsFollowUp,\n    \"process.followUpDueAt\": d.followUp.followUpDueAt,\n    \"process.followUpLevel\": d.followUp.followUpLevel,\n    \"process.needsReapplySuggestion\": d.reapply.needsReapplySuggestion,\n    \"process.reapplyEligibleAt\": d.reapply.reapplyEligibleAt,\n    \"process.reapplyReason\": d.reapply.reapplyReason,\n  };\n}\n\nexport { withRoleFingerprint };\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { normalizeText } from \"../lib/text\";\nimport {\n  ApplicationDoc,\n  MatchingBlock,\n  MatchingBreakdown,\n  MatchingDecision,\n  UserDoc,\n} from \"../types\";\n\n/**\n * Matching engine (client-side):\n * - Finds skills mentioned in roleTitle/rawDescription\n * - Computes a simple score\n * - Produces matchedSkillsTop + gapsTop\n */\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function computeMatching(\n  user: UserDoc | null,\n  app: ApplicationDoc,\n  t: Timestamp,\n): MatchingBlock | undefined {\n  if (!user) return undefined;\n\n  const text = normalizeText(\n    [\n      app.job.roleTitle,\n      app.job.companyName,\n      app.job.locationText ?? \"\",\n      app.vacancy?.rawDescription ?? \"\",\n      (app.notes?.tags ?? []).join(\" \"),\n    ].join(\" \"),\n  );\n\n  const skills = (user.skills ?? [])\n    .slice()\n    .sort((a, b) => (b.level ?? 0) - (a.level ?? 0));\n  if (skills.length === 0) return undefined;\n\n  const matched: string[] = [];\n  const gaps: string[] = [];\n\n  for (const s of skills) {\n    const tokenA = normalizeText(s.key);\n    const tokenB = normalizeText(s.label);\n    const hit =\n      (tokenA && text.includes(tokenA)) || (tokenB && text.includes(tokenB));\n    if (hit) matched.push(s.label || s.key);\n    else gaps.push(s.label || s.key);\n  }\n\n  const topMatched = matched.slice(0, 10);\n  const topGaps = gaps.slice(0, 10);\n\n  const total = skills.length;\n  const hitCount = matched.length;\n  const skillScore = Math.round((hitCount / total) * 100);\n\n  // Hard filter flags (example: remote preference)\n  const hardFilterFlags: Record<string, boolean> = {};\n  if (user.matchSettings?.hardFilters) {\n    const hf = user.matchSettings.hardFilters;\n    const workMode = app.job.workMode;\n    if (workMode === \"REMOTE\" && !hf.allowRemote)\n      hardFilterFlags.allowRemote = false;\n    if (workMode === \"HYBRID\" && !hf.allowHybrid)\n      hardFilterFlags.allowHybrid = false;\n    if (workMode === \"ON_SITE\" && !hf.allowOnSite)\n      hardFilterFlags.allowOnSite = false;\n  }\n\n  // Simple breakdown: we only have skills data right now, keep others 0\n  const breakdown: MatchingBreakdown = {\n    skills: skillScore,\n    experience: 0,\n    language: 0,\n    location: 0,\n    domain: 0,\n    salary: 0,\n  };\n\n  let score = skillScore;\n  const hasHardFails = Object.values(hardFilterFlags).some((v) => v === false);\n  if (hasHardFails) score = Math.max(0, score - 30);\n\n  let decision: MatchingDecision = \"maybe\";\n  if (score >= 70) decision = \"match\";\n  else if (score < 35) decision = \"skip\";\n\n  // Confidence: higher when we have raw description and more skills\n  const confidence = Math.min(\n    1,\n    0.3 +\n      (app.vacancy?.rawDescription ? 0.3 : 0) +\n      Math.min(0.4, skills.length / 25),\n  );\n\n  return {\n    decision,\n    score,\n    breakdown,\n    hardFilterFlags,\n    matchedSkillsTop: topMatched,\n    gapsTop: topGaps,\n    computedAt: t,\n    confidence,\n  };\n}\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { FOLLOW_UP_DAYS } from \"../lib/constants\";\nimport { addDays, daysBetween } from \"../lib/time\";\nimport { ApplicationDoc } from \"../types\";\n\n/**\n * Follow-up system (client-side):\n * needsFollowUp when:\n * - status is in active pipeline\n * - and last contact/status change is >= 7 days ago\n * - and last follow-up is not recent\n */\nexport function computeFollowUp(\n  app: ApplicationDoc,\n  t: Timestamp,\n): {\n  needsFollowUp: boolean;\n  followUpDueAt?: Timestamp;\n  followUpLevel: number;\n} {\n  const status = app.process.status;\n  const active = [\n    \"APPLIED\",\n    \"VIEWED\",\n    \"INTERVIEW_1\",\n    \"INTERVIEW_2\",\n    \"TEST_TASK\",\n  ].includes(status);\n\n  if (!active) {\n    return {\n      needsFollowUp: false,\n      followUpDueAt: undefined,\n      followUpLevel: app.process.followUpLevel ?? 0,\n    };\n  }\n\n  const ref = app.process.lastContactAt ?? app.process.lastStatusChangeAt;\n  const followUpRef = app.process.lastFollowUpAt;\n\n  const daysSinceRef = daysBetween(ref, t);\n  const daysSinceFollow = followUpRef ? daysBetween(followUpRef, t) : 999;\n\n  const dueAt = addDays(ref, FOLLOW_UP_DAYS);\n  const due = t.toMillis() >= dueAt.toMillis();\n\n  const needs =\n    daysSinceRef >= FOLLOW_UP_DAYS &&\n    daysSinceFollow >= FOLLOW_UP_DAYS &&\n    due;\n\n  return {\n    needsFollowUp: needs,\n    followUpDueAt: needs ? dueAt : undefined,\n    followUpLevel: app.process.followUpLevel ?? 0,\n  };\n}\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { REAPPLY_COOLDOWN_DAYS } from \"../lib/constants\";\nimport { addDays } from \"../lib/time\";\nimport { ApplicationDoc } from \"../types\";\n\n/**\n * Re-apply logic (client-side):\n * Suggest reapply when:\n * - status is REJECTED or NO_RESPONSE\n * - and last status change is >= 30 days ago\n */\nexport function computeReapply(\n  app: ApplicationDoc,\n  t: Timestamp,\n): {\n  needsReapplySuggestion: boolean;\n  reapplyEligibleAt?: Timestamp;\n  reapplyReason?: string;\n} {\n  const status = app.process.status;\n  const eligibleStatuses = [\"REJECTED\", \"NO_RESPONSE\"].includes(status);\n  if (!eligibleStatuses) {\n    return {\n      needsReapplySuggestion: false,\n      reapplyEligibleAt: undefined,\n      reapplyReason: undefined,\n    };\n  }\n\n  const last = app.process.lastStatusChangeAt;\n  const eligibleAt = addDays(last, REAPPLY_COOLDOWN_DAYS);\n  const eligible = t.toMillis() >= eligibleAt.toMillis();\n\n  return {\n    needsReapplySuggestion: eligible,\n    reapplyEligibleAt: eligible ? eligibleAt : undefined,\n    reapplyReason: eligible ? \"cooldown_elapsed\" : undefined,\n  };\n}\n","import { Timestamp } from \"firebase/firestore\";\n\nimport { ApplicationDoc, PriorityBlock } from \"../types\";\n\n/**\n * Priority calculation (client-side):\n * A small heuristic that helps Today view.\n */\nexport function computePriority(app: ApplicationDoc, t: Timestamp): PriorityBlock {\n  const reasons: string[] = [];\n  let score = 0;\n\n  switch (app.process.status) {\n    case \"SAVED\":\n      score = 75;\n      reasons.push(\"saved_new\");\n      break;\n    case \"PLANNED\":\n      score = 70;\n      reasons.push(\"planned\");\n      break;\n    case \"APPLIED\":\n      score = 60;\n      reasons.push(\"applied\");\n      break;\n    case \"VIEWED\":\n      score = 58;\n      reasons.push(\"viewed\");\n      break;\n    case \"INTERVIEW_1\":\n      score = 52;\n      reasons.push(\"interview\");\n      break;\n    case \"INTERVIEW_2\":\n      score = 45;\n      reasons.push(\"interview_2\");\n      break;\n    case \"TEST_TASK\":\n      score = 50;\n      reasons.push(\"test_task\");\n      break;\n    case \"OFFER\":\n      score = 30;\n      reasons.push(\"offer\");\n      break;\n    case \"REJECTED\":\n    case \"NO_RESPONSE\":\n      score = 10;\n      reasons.push(\"closed\");\n      break;\n    default:\n      score = 40;\n  }\n\n  if (app.job.vacancyUrl) {\n    score += 5;\n    reasons.push(\"has_url\");\n  }\n  if (app.process.needsFollowUp) {\n    score += 10;\n    reasons.push(\"followup_due\");\n  }\n  if (app.process.needsReapplySuggestion) {\n    score += 6;\n    reasons.push(\"reapply_possible\");\n  }\n\n  // Matching boosts priority for strong matches\n  if (app.matching?.decision === \"match\") {\n    score += 6;\n    reasons.push(\"strong_match\");\n  } else if (app.matching?.decision === \"skip\") {\n    score -= 8;\n    reasons.push(\"weak_match\");\n  }\n\n  score = Math.max(0, Math.min(100, score));\n\n  return { score, reasons, computedAt: t };\n}\n","import { Timestamp } from \"firebase/firestore\";\n\n/**\n * Firestore rejects `undefined` values.\n * We keep payloads clean by stripping undefined recursively.\n *\n * Important: preserve Firestore Timestamp instances as-is.\n */\nexport function stripUndefinedDeep<T>(value: T): T {\n  if (value === undefined || value === null) return value;\n  if (value instanceof Timestamp) return value;\n\n  if (Array.isArray(value)) {\n    return value\n      .filter((v) => v !== undefined)\n      .map((v) => stripUndefinedDeep(v)) as unknown as T;\n  }\n\n  if (typeof value === \"object\") {\n    const out: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(value as Record<string, unknown>)) {\n      if (v === undefined) continue;\n      out[k] = stripUndefinedDeep(v as unknown);\n    }\n    // `T` can be instantiated with a type unrelated to `Record<string, unknown>`.\n    // Runtime contract: we preserve the object shape while removing `undefined`.\n    return out as unknown as T;\n  }\n\n  return value;\n}\n","import { Firestore, collection, doc } from \"firebase/firestore\";\n\nexport function usersRef(db: Firestore) {\n  return collection(db, \"users\");\n}\n\nexport function userDocRef(db: Firestore, userId: string) {\n  return doc(usersRef(db), userId);\n}\n\nexport function applicationsColRef(db: Firestore, userId: string) {\n  return collection(db, \"users\", userId, \"applications\");\n}\n\nexport function applicationDocRef(db: Firestore, userId: string, appId: string) {\n  return doc(db, \"users\", userId, \"applications\", appId);\n}\n\nexport function historyColRef(db: Firestore, userId: string, appId: string) {\n  return collection(db, \"users\", userId, \"applications\", appId, \"history\");\n}\n\nexport function historyDocRef(\n  db: Firestore,\n  userId: string,\n  appId: string,\n  historyId: string,\n) {\n  return doc(db, \"users\", userId, \"applications\", appId, \"history\", historyId);\n}\n","import { DotPatch } from \"../types\";\n\nfunction isPlainObject(v: unknown): v is Record<string, unknown> {\n  if (!v || typeof v !== \"object\") return false;\n  const proto = Object.getPrototypeOf(v);\n  return proto === Object.prototype || proto === null;\n}\n\n/**\n * Deep clone that PRESERVES class instances (e.g. Firestore Timestamp).\n * We only deep-clone arrays and plain objects.\n */\nfunction deepClonePreserve<T>(value: T): T {\n  if (Array.isArray(value)) {\n    return value.map((v) => deepClonePreserve(v)) as unknown as T;\n  }\n  if (isPlainObject(value)) {\n    const out: Record<string, unknown> = {};\n    for (const [k, v] of Object.entries(value)) out[k] = deepClonePreserve(v as unknown);\n    return out as T;\n  }\n  return value;\n}\n\nexport function applyDotPatch<T extends Record<string, unknown>>(\n  base: T,\n  patch: DotPatch,\n): T {\n  // IMPORTANT: do not JSON-clone here.\n  // Firestore Timestamp has methods (toMillis, toDate, etc.). JSON cloning turns it into a plain object\n  // and later code (computeFollowUp/daysBetween) will crash with \"a.toMillis is not a function\".\n  const out = deepClonePreserve(base) as unknown as Record<string, unknown>;\n\n  for (const [k, v] of Object.entries(patch)) {\n    if (!k.includes(\".\")) {\n      out[k] = v;\n      continue;\n    }\n    const parts = k.split(\".\");\n    let cur: Record<string, unknown> = out;\n    for (let i = 0; i < parts.length - 1; i += 1) {\n      const p = parts[i];\n      const next = cur[p];\n      if (!next || typeof next !== \"object\") cur[p] = {};\n      cur = cur[p] as Record<string, unknown>;\n    }\n    cur[parts[parts.length - 1]] = v;\n  }\n  return out as T;\n}\n","import { Firestore, getDoc, writeBatch } from \"firebase/firestore\";\n\nimport { stripUndefinedDeep } from \"./lib/sanitize\";\nimport { nowTs } from \"./lib/time\";\nimport { userDocRef } from \"./refs\";\nimport { UserDoc } from \"./types\";\n\nexport async function getUserDoc(\n  db: Firestore,\n  userId: string,\n): Promise<UserDoc | null> {\n  const ref = userDocRef(db, userId);\n  const snap = await getDoc(ref);\n  return snap.exists() ? (snap.data() as UserDoc) : null;\n}\n\n/**\n * Create user root doc according to schema\n */\nexport async function ensureUserDoc(db: Firestore, userId: string): Promise<void> {\n  const ref = userDocRef(db, userId);\n  const snap = await getDoc(ref);\n  if (snap.exists()) return;\n\n  const t = nowTs();\n  const userDoc: UserDoc = {\n    createdAt: t,\n    updatedAt: t,\n    profile: { location: { timezone: \"Europe/Berlin\" } },\n    skills: [],\n    matchSettings: {\n      weights: {\n        skills: 45,\n        experience: 20,\n        language: 10,\n        location: 10,\n        domain: 10,\n        salary: 5,\n      },\n      hardFilters: { allowOnSite: true, allowHybrid: true, allowRemote: true },\n      skillSynonymsVersion: 1,\n    },\n  };\n\n  const batch = writeBatch(db);\n  batch.set(ref, stripUndefinedDeep(userDoc));\n  await batch.commit();\n}\n","import {\n  Firestore,\n  Timestamp,\n  doc,\n  getDoc,\n  getDocs,\n  limit,\n  setDoc,\n  orderBy,\n  query,\n  where,\n  writeBatch,\n} from \"firebase/firestore\";\n\ntype TimestampMillisLike = { toMillis: () => number };\ntype TimestampSecondsLike = { seconds: number; nanoseconds?: number };\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction isTimestampMillisLike(value: unknown): value is TimestampMillisLike {\n  return isObject(value) && typeof (value as TimestampMillisLike).toMillis === \"function\";\n}\n\nfunction isTimestampSecondsLike(value: unknown): value is TimestampSecondsLike {\n  return isObject(value) && typeof (value as TimestampSecondsLike).seconds === \"number\";\n}\n\nfunction toMs(value: unknown): number {\n  if (value == null) return 0;\n  if (typeof value === \"number\") return value;\n  if (value instanceof Date) return value.getTime();\n  // Firestore Timestamp has toMillis(), but we duck-type to avoid instanceof issues.\n  if (isTimestampMillisLike(value)) return value.toMillis();\n  if (isTimestampSecondsLike(value)) return value.seconds * 1000;\n  return 0;\n}\n\nimport { buildDerivedPatch, computeDerived, withRoleFingerprint } from \"./derived\";\nimport { attachCreatedAt, queueHistoryEvents } from \"./history\";\nimport { applyDotPatch } from \"./lib/patch\";\nimport { stripUndefinedDeep } from \"./lib/sanitize\";\nimport { nowTs } from \"./lib/time\";\nimport { applicationsColRef, applicationDocRef, historyColRef, historyDocRef } from \"./refs\";\nimport {\n  ApplicationDoc,\n  FeedbackType,\n  HistoryEventDoc,\n  ProcessStage,\n  ProcessStatus,\n  RejectionReasonCode,\n  Sentiment,\n  WorkMode,\n  EmploymentType,\n  DotPatch,\n} from \"./types\";\nimport { ensureUserDoc, getUserDoc } from \"./user\";\n\n/**\n * Create new application with initial history event (SYSTEM).\n * Also computes derived blocks (matching/priority/followup/reapply/fingerprint) on the client.\n */\nexport async function createApplication(\n  db: Firestore,\n  userId: string,\n  input: {\n    companyName: string;\n    roleTitle: string;\n    vacancyUrl?: string;\n    source?: string;\n    status?: ProcessStatus; // default SAVED\n    locationText?: string;\n    workMode?: WorkMode;\n    employmentType?: EmploymentType;\n    tags?: string[];\n    currentNote?: string;\n    rawDescription?: string;\n\n    // Optional loop linkage (unifies legacy loopMatches into applications)\n    loopId?: string;\n    loopPlatform?: string;\n    loopMatchedAt?: Date;\n    loopSource?: \"loop\" | \"manual\" | \"import\";\n    legacyMatchId?: string;\n  },\n): Promise<string> {\n  // Ensure user doc exists (Firestore-only mode)\n  await ensureUserDoc(db, userId);\n\n\n  // For UI consistency: Matches/Board expect applications to have loopLinkage.loopId.\n  // If user creates an application manually, we attach it to a default \"manual\" loop.\n  const effectiveLoopId = input.loopId ?? \"manual\";\n\n  // Ensure the \"manual\" loop exists (best-effort).\n  if (!input.loopId) {\n    const manualLoopRef = doc(db, \"users\", userId, \"loops\", effectiveLoopId);\n    const manualLoopSnap = await getDoc(manualLoopRef);\n    if (!manualLoopSnap.exists()) {\n      const t0 = nowTs();\n      await setDoc(manualLoopRef, {\n        name: \"Manual\",\n        titles: [],\n        location: \"\",\n        radiusKm: 0,\n        remoteMode: \"manual\",\n        platforms: [],\n        filters: {},\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        createdAtTs: t0,\n        updatedAtTs: t0,\n      });\n    }\n  }\n\n  // Use Firestore-generated IDs\n  const appId = doc(applicationsColRef(db, userId)).id;\n  const appRef = applicationDocRef(db, userId, appId);\n\n  const t = nowTs();\n  const status: ProcessStatus = input.status ?? \"SAVED\";\n\n  const appDoc: ApplicationDoc = {\n    createdAt: t,\n    updatedAt: t,\n    createdBy: userId,\n    archived: false,\n    job: {\n      companyName: input.companyName,\n      roleTitle: input.roleTitle,\n      vacancyUrl: input.vacancyUrl,\n      source: input.source,\n      locationText: input.locationText,\n      workMode: input.workMode,\n      employmentType: input.employmentType,\n    },\n    process: {\n      status,\n      lastStatusChangeAt: t,\n      contactAttempts: 0,\n      followUpLevel: 0,\n      needsFollowUp: false,\n      needsReapplySuggestion: false,\n    },\n    notes: {\n      currentNote: input.currentNote,\n      tags: input.tags ?? [],\n    },\n    vacancy: input.rawDescription\n      ? { rawDescription: input.rawDescription, roleFingerprint: undefined }\n      : undefined,\n\n    loopLinkage: {\n      loopId: effectiveLoopId,\n      platform: input.loopPlatform,\n      matchedAt: input.loopMatchedAt\n        ? Timestamp.fromDate(input.loopMatchedAt)\n        : undefined,\n      source: input.loopSource ?? (input.loopId ? \"loop\" : \"manual\"),\n      legacyMatchId: input.legacyMatchId,\n    },\n  };\n\n  // Derived fields\n  const user = await getUserDoc(db, userId);\n  const derived = computeDerived(user, appDoc, t);\n  const derivedApp: ApplicationDoc = {\n    ...withRoleFingerprint(appDoc, derived.roleFingerprint),\n    matching: derived.matching,\n    process: {\n      ...appDoc.process,\n      ...derived.followUp,\n      ...derived.reapply,\n    },\n    priority: derived.priority,\n  };\n\n  const batch = writeBatch(db);\n  batch.set(appRef, stripUndefinedDeep(derivedApp));\n\n  // Initial history event (SYSTEM)\n  const hId = doc(historyColRef(db, userId, appId)).id;\n  const hRef = historyDocRef(db, userId, appId, hId);\n  const h: HistoryEventDoc = {\n    createdAt: t,\n    actor: \"system\",\n    type: \"SYSTEM\",\n    comment: \"Application created\",\n  };\n  batch.set(hRef, stripUndefinedDeep(h));\n\n  await batch.commit();\n  return appId;\n}\n\n/**\n * Fetch one application by id\n */\nexport async function getApplication(\n  db: Firestore,\n  userId: string,\n  appId: string,\n): Promise<ApplicationDoc | null> {\n  const ref = applicationDocRef(db, userId, appId);\n  const snap = await getDoc(ref);\n  return snap.exists() ? (snap.data() as ApplicationDoc) : null;\n}\n\n/**\n * Load latest history (descending)\n */\nexport async function getApplicationHistory(\n  db: Firestore,\n  userId: string,\n  appId: string,\n  take: number = 50,\n): Promise<Array<{ id: string; data: HistoryEventDoc }>> {\n  const q = query(\n    historyColRef(db, userId, appId),\n    orderBy(\"createdAt\", \"desc\"),\n    limit(take),\n  );\n  const snap = await getDocs(q);\n  return snap.docs.map((d) => ({\n    id: d.id,\n    data: d.data() as HistoryEventDoc,\n  }));\n}\n\n/**\n * Update application with history event(s) in ONE batch.\n * Also recomputes derived fields (matching/priority/followup/reapply/fingerprint) client-side.\n *\n * NOTE: patch may include dot-path keys (e.g. \"process.status\").\n */\nexport async function updateApplicationWithHistory(\n  db: Firestore,\n  userId: string,\n  appId: string,\n  patch: Partial<ApplicationDoc> | Record<string, unknown>,\n  buildHistory: (current: ApplicationDoc) => HistoryEventDoc[],\n): Promise<void> {\n  const appRef = applicationDocRef(db, userId, appId);\n  const snap = await getDoc(appRef);\n  if (!snap.exists()) throw new Error(`Application ${appId} not found`);\n\n  const current = snap.data() as ApplicationDoc;\n  const t = nowTs();\n\n  const patchObj = patch as Record<string, unknown>;\n  const patchRaw: DotPatch = { ...patchObj, updatedAt: t };\n  const next = applyDotPatch(current as unknown as Record<string, unknown>, patchRaw) as unknown as ApplicationDoc;\n\n  // Derived\n  const user = await getUserDoc(db, userId);\n  const derived = computeDerived(user, next, t);\n  const patchFinal = stripUndefinedDeep({\n    ...patchRaw,\n    ...buildDerivedPatch(derived),\n  });\n\n  const events = attachCreatedAt(buildHistory(current), t);\n\n  const batch = writeBatch(db);\n  batch.update(appRef, patchFinal);\n  queueHistoryEvents(batch, db, userId, appId, events);\n  await batch.commit();\n}\n\n/**\n * Convenience: change status (writes STATUS_CHANGE + updates lastStatusChangeAt)\n */\nexport async function changeStatus(\n  db: Firestore,\n  userId: string,\n  appId: string,\n  toStatus: ProcessStatus,\n): Promise<void> {\n  // We need current doc to avoid resetting appliedAt repeatedly.\n  const appRef = applicationDocRef(db, userId, appId);\n  const snap = await getDoc(appRef);\n  if (!snap.exists()) throw new Error(`Application ${appId} not found`);\n  const current = snap.data() as ApplicationDoc;\n\n  const t = nowTs();\n  const patch: Record<string, unknown> = {\n    \"process.status\": toStatus,\n    \"process.lastStatusChangeAt\": t,\n  };\n\n  // Keep Board/Columns (stage-based) in sync with legacy status changes.\n  // This is intentionally simple and backward-compatible: we always write\n  // stage/subStatus alongside the legacy status.\n  const mapLegacyToStageSub = (\n    s: ProcessStatus,\n  ): { stage: ProcessStage; subStatus: string } => {\n    switch (s) {\n      case \"SAVED\":\n        return { stage: \"ACTIVE\", subStatus: \"SAVED\" };\n      case \"APPLIED\":\n        return { stage: \"ACTIVE\", subStatus: \"APPLIED\" };\n      case \"INTERVIEW_1\":\n        return { stage: \"INTERVIEW\", subStatus: \"HR_CALL_SCHEDULED\" };\n      case \"OFFER\":\n        return { stage: \"OFFER\", subStatus: \"OFFER_RECEIVED\" };\n      case \"REJECTED\":\n        return { stage: \"REJECTED\", subStatus: \"REJECTED_PRE_INTERVIEW\" };\n      case \"NO_RESPONSE\":\n        return { stage: \"NO_RESPONSE\", subStatus: \"GHOSTING\" };\n      default:\n        return { stage: \"ACTIVE\", subStatus: \"SAVED\" };\n    }\n  };\n\n  const mapped = mapLegacyToStageSub(toStatus);\n  patch[\"process.stage\"] = mapped.stage;\n  patch[\"process.subStatus\"] = mapped.subStatus;\n\n  // Track when an application was actually applied.\n  if (toStatus === \"APPLIED\" && !current.process.appliedAt) {\n    patch[\"process.appliedAt\"] = t;\n  }\n\n  await updateApplicationWithHistory(\n    db,\n    userId,\n    appId,\n    patch,\n    () => [\n      {\n        actor: \"user\",\n        type: \"STATUS_CHANGE\",\n        fromStatus: current.process.status,\n        toStatus,\n      },\n    ],\n  );\n}\n\n/**\n * Client-side automation: mark applications as NO_RESPONSE/GHOSTING\n * when appliedAt is older than `days` (default 30 days).\n *\n * This is a \"best possible\" automation without Cloud Functions: it runs when user opens lists.\n */\nexport async function autoMarkGhosting(\n  db: Firestore,\n  userId: string,\n  rows: Array<{ id: string; data: ApplicationDoc }>,\n  days: number = 30,\n): Promise<number> {\n  const ms = days * 24 * 60 * 60 * 1000;\n  const now = Date.now();\n\n  const toUpdate = rows.filter(({ data }) => {\n    if (data.archived) return false;\n    if (data.process.status === \"NO_RESPONSE\") return false;\n    const appliedAt = data.process.appliedAt;\n    if (!appliedAt) return false;\n    const appliedMs = appliedAt.toDate().getTime();\n    return appliedMs <= now - ms;\n  });\n\n  if (!toUpdate.length) return 0;\n\n  const t = nowTs();\n  const batch = writeBatch(db);\n\n  for (const { id, data } of toUpdate) {\n    const appRef = applicationDocRef(db, userId, id);\n    const update: Record<string, unknown> = {\n      \"process.status\": \"NO_RESPONSE\",\n      \"process.lastStatusChangeAt\": t,\n      \"process.stage\": \"NO_RESPONSE\",\n      \"process.subStatus\": \"GHOSTING\",\n      updatedAt: t,\n    };\n    batch.update(appRef, update);\n\n    // History event\n    const hId = doc(historyColRef(db, userId, id)).id;\n    const hRef = historyDocRef(db, userId, id, hId);\n    const h: HistoryEventDoc = {\n      createdAt: t,\n      actor: \"system\",\n      type: \"STATUS_CHANGE\",\n      fromStatus: data.process.status,\n      toStatus: \"NO_RESPONSE\",\n      comment: \"Auto-marked as GHOSTING (no response > 30 days)\",\n    };\n    batch.set(hRef, stripUndefinedDeep(h));\n  }\n\n  await batch.commit();\n  return toUpdate.length;\n}\n\n/**\n * Convenience: add comment history event (no application change needed except updatedAt)\n */\nexport async function addComment(\n  db: Firestore,\n  userId: string,\n  appId: string,\n  comment: {\n    text: string;\n    feedbackType?: FeedbackType;\n    sentiment?: Sentiment;\n    rejectionReasonCode?: RejectionReasonCode;\n  },\n): Promise<void> {\n  await updateApplicationWithHistory(db, userId, appId, {}, () => [\n    {\n      actor: \"user\",\n      type: \"COMMENT\",\n      comment: comment.text,\n      feedbackType: comment.feedbackType,\n      sentiment: comment.sentiment,\n      rejectionReasonCode: comment.rejectionReasonCode,\n    },\n  ]);\n}\n\n/**\n * Queries (Pipeline / Today / Follow-ups)\n */\nexport async function queryPipelineByStatus(\n  db: Firestore,\n  userId: string,\n  status: ProcessStatus,\n  take: number = 50,\n): Promise<Array<{ id: string; data: ApplicationDoc }>> {\n  // Avoid composite indexes by querying by status only and filtering/sorting client-side.\n  // This keeps a fresh Firebase project usable without having to create indexes.\n  const q = query(\n    applicationsColRef(db, userId),\n    where(\"process.status\", \"==\", status),\n    // oversample a bit because we filter archived client-side\n    limit(take * 3),\n  );\n  const snap = await getDocs(q);\n  return snap.docs\n    .map((d) => ({ id: d.id, data: d.data() as ApplicationDoc }))\n    .filter((x) => !x.data.archived)\n    .sort(\n      (a, b) =>\n        toMs(b.data.process.lastStatusChangeAt) - toMs(a.data.process.lastStatusChangeAt),\n    )\n    .slice(0, take);\n}\n\nexport async function queryTodayTopPriority(\n  db: Firestore,\n  userId: string,\n  take: number = 20,\n): Promise<Array<{ id: string; data: ApplicationDoc }>> {\n  // Avoid composite index by ordering only and filtering archived client-side.\n  const q = query(\n    applicationsColRef(db, userId),\n    orderBy(\"priority.score\", \"desc\"),\n    limit(take * 3),\n  );\n  const snap = await getDocs(q);\n  return snap.docs\n    .map((d) => ({ id: d.id, data: d.data() as ApplicationDoc }))\n    .filter((x) => !x.data.archived)\n    .slice(0, take);\n}\n\nexport async function queryFollowUpsDue(\n  db: Firestore,\n  userId: string,\n  take: number = 50,\n): Promise<Array<{ id: string; data: ApplicationDoc }>> {\n  // Avoid composite indexes by querying by needsFollowUp only and sorting client-side.\n  const q = query(\n    applicationsColRef(db, userId),\n    where(\"process.needsFollowUp\", \"==\", true),\n    limit(take * 3),\n  );\n  const snap = await getDocs(q);\n  return snap.docs\n    .map((d) => ({ id: d.id, data: d.data() as ApplicationDoc }))\n    .filter((x) => !x.data.archived)\n    .sort((a, b) => toMs(a.data.process.followUpDueAt) - toMs(b.data.process.followUpDueAt))\n    .slice(0, take);\n}\n\n/**\n * Fetch all active (not archived) applications.\n *\n * NOTE:\n * - Intentionally does NOT use orderBy to avoid requiring additional composite indexes.\n * - Sort client-side if you need recency.\n */\nexport async function queryAllActiveApplications(\n  db: Firestore,\n  userId: string,\n  take: number = 500,\n): Promise<Array<{ id: string; data: ApplicationDoc }>> {\n  const q = query(\n    applicationsColRef(db, userId),\n    where(\"archived\", \"==\", false),\n    limit(take),\n  );\n  const snap = await getDocs(q);\n  return snap.docs.map((d) => ({ id: d.id, data: d.data() as ApplicationDoc }));\n}\n\n// Re-exported for backwards compatibility with older imports.\nexport { ensureUserDoc } from \"./user\";\n","import { Firestore, Timestamp, doc, writeBatch } from \"firebase/firestore\";\n\nimport { stripUndefinedDeep } from \"./lib/sanitize\";\nimport { historyColRef, historyDocRef } from \"./refs\";\nimport { HistoryEventDoc } from \"./types\";\n\nexport function attachCreatedAt(events: HistoryEventDoc[], t: Timestamp) {\n  return events.map((e) => ({ ...e, createdAt: e.createdAt ?? t }));\n}\n\nexport function queueHistoryEvents(\n  batch: ReturnType<typeof writeBatch>,\n  db: Firestore,\n  userId: string,\n  appId: string,\n  events: HistoryEventDoc[],\n) {\n  for (const ev of events) {\n    const hId = doc(historyColRef(db, userId, appId)).id;\n    const hRef = historyDocRef(db, userId, appId, hId);\n    batch.set(hRef, stripUndefinedDeep(ev));\n  }\n}\n"],"names":["normalizeText","s","toLowerCase","replace","trim","withRoleFingerprint","app","roleFingerprint","vacancy","DAY_MS","nowTs","Timestamp","now","addDays","ts","days","fromMillis","toMillis","daysBetween","a","b","Math","floor","abs","computeDerived","user","t","input","hash","i","length","charCodeAt","toString","djb2Hash","job","companyName","roleTitle","locationText","computeRoleFingerprint","base","matching","text","rawDescription","notes","tags","join","skills","slice","sort","level","matched","gaps","tokenA","key","tokenB","label","includes","push","topMatched","topGaps","total","hitCount","skillScore","round","hardFilterFlags","matchSettings","hardFilters","hf","workMode","allowRemote","allowHybrid","allowOnSite","breakdown","experience","language","location","domain","salary","score","Object","values","some","v","max","decision","matchedSkillsTop","gapsTop","computedAt","confidence","min","computeMatching","followUp","status","process","needsFollowUp","followUpDueAt","undefined","followUpLevel","ref","lastContactAt","lastStatusChangeAt","followUpRef","lastFollowUpAt","daysSinceRef","daysSinceFollow","dueAt","due","needs","computeFollowUp","reapply","needsReapplySuggestion","reapplyEligibleAt","reapplyReason","eligibleAt","eligible","computeReapply","priority","reasons","vacancyUrl","computePriority","stripUndefinedDeep","value","Array","isArray","filter","map","out","k","entries","userDocRef","db","userId","doc","collection","usersRef","applicationsColRef","applicationDocRef","appId","historyColRef","historyDocRef","historyId","deepClonePreserve","proto","getPrototypeOf","prototype","isPlainObject","async","getUserDoc","snap","getDoc","exists","data","ensureUserDoc","userDoc","createdAt","updatedAt","profile","timezone","weights","skillSynonymsVersion","batch","writeBatch","set","commit","isObject","toMs","Date","getTime","isTimestampMillisLike","seconds","isTimestampSecondsLike","createApplication","effectiveLoopId","loopId","manualLoopRef","t0","setDoc","name","titles","radiusKm","remoteMode","platforms","filters","toISOString","createdAtTs","updatedAtTs","id","appRef","appDoc","createdBy","archived","source","employmentType","contactAttempts","currentNote","loopLinkage","platform","loopPlatform","matchedAt","loopMatchedAt","fromDate","loopSource","legacyMatchId","derived","derivedApp","hRef","h","actor","type","comment","getApplication","getApplicationHistory","take","q","query","orderBy","limit","getDocs","docs","d","updateApplicationWithHistory","patch","buildHistory","Error","current","patchRaw","next","parts","split","cur","p","applyDotPatch","patchFinal","events","e","attachCreatedAt","update","ev","queueHistoryEvents","changeStatus","toStatus","mapped","stage","subStatus","mapLegacyToStageSub","appliedAt","fromStatus","autoMarkGhosting","rows","ms","toUpdate","toDate","addComment","feedbackType","sentiment","rejectionReasonCode","queryPipelineByStatus","where","x","queryTodayTopPriority","queryFollowUpsDue","queryAllActiveApplications"],"ignoreList":[],"sourceRoot":""}